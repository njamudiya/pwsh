#
# TrustedInfrastructure Paths
# The vcenter trusted_infrastructure package provides services that enable a Trusted Infrastructure. They are responsible for ensuring that infrastructure nodes are running trusted software and for releasing encryption keys only to trusted infrastructure nodes.
# Version: v7.0U3
# Contact: powercli@vmware.com
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

Configures the cluster to use a the given registered Attestation Service.

.DESCRIPTION

No description available.

.PARAMETER Cluster
The ID of the cluster. The parameter must be an identifier for the resource type: ClusterComputeResource.

.PARAMETER TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

String

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/attestation/servicesvmw-tasktrue/post/
#>
function Invoke-CreateClusterAttestationServicesAsync {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/attestation/servicesvmw-tasktrue/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Cluster},
        [Parameter(Mandatory = $true, Position = 1, ValueFromPipelineByPropertyName = $true)]
        [PSTypeName("TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec")]
        [PSCustomObject]
        ${TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-CreateClusterAttestationServicesAsync' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'CreateClusterAttestationServicesAsync' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/trusted-clusters/{cluster}/attestation/services__vmw-task=true'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Cluster) {
                    throw "Error! The required parameter `Cluster` missing when calling createClusterAttestationServicesAsync."
                }
                $LocalVarUri = $LocalVarUri.replace('{cluster}', $Cluster)
                $LocalVarPathParameters['cluster'] = $Cluster
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if (!$TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec) {
                    throw "Error! The required parameter `TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec` missing when calling createClusterAttestationServicesAsync."
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec) {
                    $LocalVarBodyParameter = $TrustedInfrastructureTrustedClustersAttestationServicesCreateSpec | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "String"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Configures the cluster to use a the given registered Key Provider Service.

.DESCRIPTION

No description available.

.PARAMETER Cluster
The ID of the cluster. The parameter must be an identifier for the resource type: ClusterComputeResource.

.PARAMETER TrustedInfrastructureTrustedClustersKmsServicesCreateSpec
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

String

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/kms/servicesvmw-tasktrue/post/
#>
function Invoke-CreateClusterKmsServicesAsync {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/kms/servicesvmw-tasktrue/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Cluster},
        [Parameter(Mandatory = $true, Position = 1, ValueFromPipelineByPropertyName = $true)]
        [PSTypeName("TrustedInfrastructureTrustedClustersKmsServicesCreateSpec")]
        [PSCustomObject]
        ${TrustedInfrastructureTrustedClustersKmsServicesCreateSpec},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-CreateClusterKmsServicesAsync' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'CreateClusterKmsServicesAsync' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/trusted-clusters/{cluster}/kms/services__vmw-task=true'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Cluster) {
                    throw "Error! The required parameter `Cluster` missing when calling createClusterKmsServicesAsync."
                }
                $LocalVarUri = $LocalVarUri.replace('{cluster}', $Cluster)
                $LocalVarPathParameters['cluster'] = $Cluster
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if (!$TrustedInfrastructureTrustedClustersKmsServicesCreateSpec) {
                    throw "Error! The required parameter `TrustedInfrastructureTrustedClustersKmsServicesCreateSpec` missing when calling createClusterKmsServicesAsync."
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $TrustedInfrastructureTrustedClustersKmsServicesCreateSpec -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$TrustedInfrastructureTrustedClustersKmsServicesCreateSpec)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureTrustedClustersKmsServicesCreateSpec -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureTrustedClustersKmsServicesCreateSpec -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $TrustedInfrastructureTrustedClustersKmsServicesCreateSpec = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $TrustedInfrastructureTrustedClustersKmsServicesCreateSpec) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $TrustedInfrastructureTrustedClustersKmsServicesCreateSpec | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $TrustedInfrastructureTrustedClustersKmsServicesCreateSpec = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $TrustedInfrastructureTrustedClustersKmsServicesCreateSpec) {
                    $LocalVarBodyParameter = $TrustedInfrastructureTrustedClustersKmsServicesCreateSpec | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "String"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Registers a new Attestation Service instance in this vCenter. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ManageTrustedHosts.  

.DESCRIPTION

No description available.

.PARAMETER TrustedInfrastructureAttestationServicesCreateSpec
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

String

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/attestation/services/post/
#>
function Invoke-CreateTrustedInfrastructureAttestationServices {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/attestation/services/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [PSTypeName("TrustedInfrastructureAttestationServicesCreateSpec")]
        [PSCustomObject]
        ${TrustedInfrastructureAttestationServicesCreateSpec},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-CreateTrustedInfrastructureAttestationServices' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'CreateTrustedInfrastructureAttestationServices' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/attestation/services'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if (!$TrustedInfrastructureAttestationServicesCreateSpec) {
                    throw "Error! The required parameter `TrustedInfrastructureAttestationServicesCreateSpec` missing when calling createTrustedInfrastructureAttestationServices."
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $TrustedInfrastructureAttestationServicesCreateSpec -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$TrustedInfrastructureAttestationServicesCreateSpec)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureAttestationServicesCreateSpec -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureAttestationServicesCreateSpec -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $TrustedInfrastructureAttestationServicesCreateSpec = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $TrustedInfrastructureAttestationServicesCreateSpec) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $TrustedInfrastructureAttestationServicesCreateSpec | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $TrustedInfrastructureAttestationServicesCreateSpec = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $TrustedInfrastructureAttestationServicesCreateSpec) {
                    $LocalVarBodyParameter = $TrustedInfrastructureAttestationServicesCreateSpec | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "String"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Registers a Key Provider Service instance in this vCenter. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ManageTrustedHosts.  

.DESCRIPTION

No description available.

.PARAMETER TrustedInfrastructureKmsServicesCreateSpec
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

String

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/kms/services/post/
#>
function Invoke-CreateTrustedInfrastructureKmsServices {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/kms/services/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [PSTypeName("TrustedInfrastructureKmsServicesCreateSpec")]
        [PSCustomObject]
        ${TrustedInfrastructureKmsServicesCreateSpec},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-CreateTrustedInfrastructureKmsServices' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'CreateTrustedInfrastructureKmsServices' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/kms/services'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if (!$TrustedInfrastructureKmsServicesCreateSpec) {
                    throw "Error! The required parameter `TrustedInfrastructureKmsServicesCreateSpec` missing when calling createTrustedInfrastructureKmsServices."
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $TrustedInfrastructureKmsServicesCreateSpec -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$TrustedInfrastructureKmsServicesCreateSpec)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureKmsServicesCreateSpec -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureKmsServicesCreateSpec -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $TrustedInfrastructureKmsServicesCreateSpec = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $TrustedInfrastructureKmsServicesCreateSpec) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $TrustedInfrastructureKmsServicesCreateSpec | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $TrustedInfrastructureKmsServicesCreateSpec = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $TrustedInfrastructureKmsServicesCreateSpec) {
                    $LocalVarBodyParameter = $TrustedInfrastructureKmsServicesCreateSpec | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "String"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Removes the Attestation Service instance from the configuration of the given cluster.

.DESCRIPTION

No description available.

.PARAMETER Cluster
the unique ID of the cluster. The parameter must be an identifier for the resource type: ClusterComputeResource.

.PARAMETER Service
the registered Attestation Service instance unique identifier. The parameter must be an identifier for the resource type: com.vmware.vcenter.trusted_infrastructure.attestation.Service.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

String

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/attestation/services/servicevmw-tasktrue/delete/
#>
function Invoke-DeleteClusterServiceAsync {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'High',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/attestation/services/servicevmw-tasktrue/delete/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Cluster},
        [Parameter(Mandatory = $true, Position = 1, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Service},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-DeleteClusterServiceAsync' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'DeleteClusterServiceAsync' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/trusted-clusters/{cluster}/attestation/services/{service}__vmw-task=true'
                $LocalVarMethod = 'DELETE'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Cluster) {
                    throw "Error! The required parameter `Cluster` missing when calling deleteClusterServiceAsync."
                }
                $LocalVarUri = $LocalVarUri.replace('{cluster}', $Cluster)
                $LocalVarPathParameters['cluster'] = $Cluster
                if (!$Service) {
                    throw "Error! The required parameter `Service` missing when calling deleteClusterServiceAsync."
                }
                $LocalVarUri = $LocalVarUri.replace('{service}', $Service)
                $LocalVarPathParameters['service'] = $Service
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "String"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Removes the Key Provider Service instance from the configuration of the given cluster.

.DESCRIPTION

No description available.

.PARAMETER Cluster
the unique ID of the cluster. The parameter must be an identifier for the resource type: ClusterComputeResource.

.PARAMETER Service
the registered Key Provider Service instance unique identifier. The parameter must be an identifier for the resource type: com.vmware.vcenter.trusted_infrastructure.kms.Service.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

String

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/kms/services/servicevmw-tasktrue/delete/
#>
function Invoke-DeleteClusterServiceAsync_0 {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'High',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/kms/services/servicevmw-tasktrue/delete/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Cluster},
        [Parameter(Mandatory = $true, Position = 1, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Service},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-DeleteClusterServiceAsync_0' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'DeleteClusterServiceAsync_0' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/trusted-clusters/{cluster}/kms/services/{service}__vmw-task=true'
                $LocalVarMethod = 'DELETE'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Cluster) {
                    throw "Error! The required parameter `Cluster` missing when calling deleteClusterServiceAsync_0."
                }
                $LocalVarUri = $LocalVarUri.replace('{cluster}', $Cluster)
                $LocalVarPathParameters['cluster'] = $Cluster
                if (!$Service) {
                    throw "Error! The required parameter `Service` missing when calling deleteClusterServiceAsync_0."
                }
                $LocalVarUri = $LocalVarUri.replace('{service}', $Service)
                $LocalVarPathParameters['service'] = $Service
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "String"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Removes a registered Attestation Service instance from this vCenter. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ManageTrustedHosts.  

.DESCRIPTION

No description available.

.PARAMETER Service
the Attestation Service instance unique identifier. The parameter must be an identifier for the resource type: com.vmware.vcenter.trusted_infrastructure.attestation.Service.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

None

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/attestation/services/service/delete/
#>
function Invoke-DeleteServiceAttestation {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'High',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/attestation/services/service/delete/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Service},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-DeleteServiceAttestation' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'DeleteServiceAttestation' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/attestation/services/{service}'
                $LocalVarMethod = 'DELETE'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Service) {
                    throw "Error! The required parameter `Service` missing when calling deleteServiceAttestation."
                }
                $LocalVarUri = $LocalVarUri.replace('{service}', $Service)
                $LocalVarPathParameters['service'] = $Service
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = ""
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Removes a currently registered Key Provider Service instance from this vCenter. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ManageTrustedHosts.  

.DESCRIPTION

No description available.

.PARAMETER Service
the Key Provider Service instance unique identifier. The parameter must be an identifier for the resource type: com.vmware.vcenter.trusted_infrastructure.kms.Service.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

None

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/kms/services/service/delete/
#>
function Invoke-DeleteServiceKms {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'High',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/kms/services/service/delete/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Service},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-DeleteServiceKms' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'DeleteServiceKms' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/kms/services/{service}'
                $LocalVarMethod = 'DELETE'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Service) {
                    throw "Error! The required parameter `Service` missing when calling deleteServiceKms."
                }
                $LocalVarUri = $LocalVarUri.replace('{service}', $Service)
                $LocalVarPathParameters['service'] = $Service
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = ""
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Returns detailed information about the given registered Attestation Service instance that is configured for the given cluster. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ReadTrustedHosts.    -  The resource ClusterComputeResource referenced by the parameter cluster requires System.View.  

.DESCRIPTION

No description available.

.PARAMETER Cluster
The ID of the cluster. The parameter must be an identifier for the resource type: ClusterComputeResource.

.PARAMETER Service
The ID of the service. The parameter must be an identifier for the resource type: com.vmware.vcenter.trusted_infrastructure.attestation.Service.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

TrustedInfrastructureTrustedClustersAttestationServicesInfo

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/attestation/services/service/get/
#>
function Invoke-GetClusterServiceAttestation {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'None',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/attestation/services/service/get/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Cluster},
        [Parameter(Mandatory = $true, Position = 1, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Service},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-GetClusterServiceAttestation' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'GetClusterServiceAttestation' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/trusted-clusters/{cluster}/attestation/services/{service}'
                $LocalVarMethod = 'GET'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Cluster) {
                    throw "Error! The required parameter `Cluster` missing when calling getClusterServiceAttestation."
                }
                $LocalVarUri = $LocalVarUri.replace('{cluster}', $Cluster)
                $LocalVarPathParameters['cluster'] = $Cluster
                if (!$Service) {
                    throw "Error! The required parameter `Service` missing when calling getClusterServiceAttestation."
                }
                $LocalVarUri = $LocalVarUri.replace('{service}', $Service)
                $LocalVarPathParameters['service'] = $Service
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "TrustedInfrastructureTrustedClustersAttestationServicesInfo"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        $SingleServerResult["Response"].PSObject.TypeNames.Insert(0, "TrustedInfrastructureTrustedClustersAttestationServicesInfo")

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Returns detailed information about the given Key Provider Service instance used by the given cluster. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ReadTrustedHosts.    -  The resource ClusterComputeResource referenced by the parameter cluster requires System.View.  

.DESCRIPTION

No description available.

.PARAMETER Cluster
The ID of the cluster. The parameter must be an identifier for the resource type: ClusterComputeResource.

.PARAMETER Service
The ID of the service. The parameter must be an identifier for the resource type: com.vmware.vcenter.trusted_infrastructure.kms.Service.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

TrustedInfrastructureTrustedClustersKmsServicesInfo

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/kms/services/service/get/
#>
function Invoke-GetClusterServiceKms {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'None',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/kms/services/service/get/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Cluster},
        [Parameter(Mandatory = $true, Position = 1, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Service},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-GetClusterServiceKms' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'GetClusterServiceKms' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/trusted-clusters/{cluster}/kms/services/{service}'
                $LocalVarMethod = 'GET'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Cluster) {
                    throw "Error! The required parameter `Cluster` missing when calling getClusterServiceKms."
                }
                $LocalVarUri = $LocalVarUri.replace('{cluster}', $Cluster)
                $LocalVarPathParameters['cluster'] = $Cluster
                if (!$Service) {
                    throw "Error! The required parameter `Service` missing when calling getClusterServiceKms."
                }
                $LocalVarUri = $LocalVarUri.replace('{service}', $Service)
                $LocalVarPathParameters['service'] = $Service
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "TrustedInfrastructureTrustedClustersKmsServicesInfo"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        $SingleServerResult["Response"].PSObject.TypeNames.Insert(0, "TrustedInfrastructureTrustedClustersKmsServicesInfo")

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Returns the detailed information about a registered Attestation Service instance in this vCenter. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ReadTrustedHosts.  

.DESCRIPTION

No description available.

.PARAMETER Service
the Attestation Service instance unique identifier. The parameter must be an identifier for the resource type: com.vmware.vcenter.trusted_infrastructure.attestation.Service.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

TrustedInfrastructureAttestationServicesInfo

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/attestation/services/service/get/
#>
function Invoke-GetServiceAttestation {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'None',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/attestation/services/service/get/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Service},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-GetServiceAttestation' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'GetServiceAttestation' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/attestation/services/{service}'
                $LocalVarMethod = 'GET'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Service) {
                    throw "Error! The required parameter `Service` missing when calling getServiceAttestation."
                }
                $LocalVarUri = $LocalVarUri.replace('{service}', $Service)
                $LocalVarPathParameters['service'] = $Service
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "TrustedInfrastructureAttestationServicesInfo"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        $SingleServerResult["Response"].PSObject.TypeNames.Insert(0, "TrustedInfrastructureAttestationServicesInfo")

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Returns the detailed information about a registered Key Provider Service instance in this vCenter. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ReadTrustedHosts.  

.DESCRIPTION

No description available.

.PARAMETER Service
the Key Provider Service instance unique identifier. The parameter must be an identifier for the resource type: com.vmware.vcenter.trusted_infrastructure.kms.Service.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

TrustedInfrastructureKmsServicesInfo

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/kms/services/service/get/
#>
function Invoke-GetServiceKms {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'None',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/kms/services/service/get/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Service},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-GetServiceKms' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'GetServiceKms' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/kms/services/{service}'
                $LocalVarMethod = 'GET'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Service) {
                    throw "Error! The required parameter `Service` missing when calling getServiceKms."
                }
                $LocalVarUri = $LocalVarUri.replace('{service}', $Service)
                $LocalVarPathParameters['service'] = $Service
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "TrustedInfrastructureKmsServicesInfo"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        $SingleServerResult["Response"].PSObject.TypeNames.Insert(0, "TrustedInfrastructureKmsServicesInfo")

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Returns detailed information about all registered Attestation Service instances in this vCenter. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ReadTrustedHosts.  

.DESCRIPTION

No description available.

.PARAMETER TrustedInfrastructureAttestationServicesFilterSpec
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

TrustedInfrastructureAttestationServicesSummary[]

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/attestation/servicesactionquery/post/
#>
function Invoke-QueryAttestationServices {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/attestation/servicesactionquery/post/"
    )]
    Param (
        [Parameter(Mandatory = $false, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [PSTypeName("TrustedInfrastructureAttestationServicesFilterSpec")]
        [PSCustomObject]
        ${TrustedInfrastructureAttestationServicesFilterSpec},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-QueryAttestationServices' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'QueryAttestationServices' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/attestation/services__action=query'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $TrustedInfrastructureAttestationServicesFilterSpec -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$TrustedInfrastructureAttestationServicesFilterSpec)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureAttestationServicesFilterSpec -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureAttestationServicesFilterSpec -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $TrustedInfrastructureAttestationServicesFilterSpec = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $TrustedInfrastructureAttestationServicesFilterSpec) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $TrustedInfrastructureAttestationServicesFilterSpec | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $TrustedInfrastructureAttestationServicesFilterSpec = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $TrustedInfrastructureAttestationServicesFilterSpec) {
                    $LocalVarBodyParameter = $TrustedInfrastructureAttestationServicesFilterSpec | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "TrustedInfrastructureAttestationServicesSummary[]"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        foreach ($element in $SingleServerResult["Response"]) {
                            $element.PSObject.TypeNames.Insert(0, "TrustedInfrastructureAttestationServicesSummary")
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Returns the basic information about all configured Attestation Service instances used by this cluster. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ReadTrustedHosts.    -  The resource ClusterComputeResource referenced by the parameter cluster requires System.View.  

.DESCRIPTION

No description available.

.PARAMETER Cluster
The ID of the cluster. The parameter must be an identifier for the resource type: ClusterComputeResource.

.PARAMETER TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

TrustedInfrastructureTrustedClustersAttestationServicesSummary[]

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/attestation/servicesactionquery/post/
#>
function Invoke-QueryClusterAttestationServices {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/attestation/servicesactionquery/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Cluster},
        [Parameter(Mandatory = $false, Position = 1, ValueFromPipelineByPropertyName = $true)]
        [PSTypeName("TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec")]
        [PSCustomObject]
        ${TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-QueryClusterAttestationServices' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'QueryClusterAttestationServices' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/trusted-clusters/{cluster}/attestation/services__action=query'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Cluster) {
                    throw "Error! The required parameter `Cluster` missing when calling queryClusterAttestationServices."
                }
                $LocalVarUri = $LocalVarUri.replace('{cluster}', $Cluster)
                $LocalVarPathParameters['cluster'] = $Cluster
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec) {
                    $LocalVarBodyParameter = $TrustedInfrastructureTrustedClustersAttestationServicesFilterSpec | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "TrustedInfrastructureTrustedClustersAttestationServicesSummary[]"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        foreach ($element in $SingleServerResult["Response"]) {
                            $element.PSObject.TypeNames.Insert(0, "TrustedInfrastructureTrustedClustersAttestationServicesSummary")
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Returns basic information about all configured Key Provider Service instances used by this cluster. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ReadTrustedHosts.    -  The resource ClusterComputeResource referenced by the parameter cluster requires System.View.  

.DESCRIPTION

No description available.

.PARAMETER Cluster
The ID of the cluster. The parameter must be an identifier for the resource type: ClusterComputeResource.

.PARAMETER TrustedInfrastructureTrustedClustersKmsServicesFilterSpec
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

TrustedInfrastructureTrustedClustersKmsServicesSummary[]

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/kms/servicesactionquery/post/
#>
function Invoke-QueryClusterKmsServices {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/trusted-clusters/cluster/kms/servicesactionquery/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Cluster},
        [Parameter(Mandatory = $false, Position = 1, ValueFromPipelineByPropertyName = $true)]
        [PSTypeName("TrustedInfrastructureTrustedClustersKmsServicesFilterSpec")]
        [PSCustomObject]
        ${TrustedInfrastructureTrustedClustersKmsServicesFilterSpec},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-QueryClusterKmsServices' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'QueryClusterKmsServices' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/trusted-clusters/{cluster}/kms/services__action=query'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Cluster) {
                    throw "Error! The required parameter `Cluster` missing when calling queryClusterKmsServices."
                }
                $LocalVarUri = $LocalVarUri.replace('{cluster}', $Cluster)
                $LocalVarPathParameters['cluster'] = $Cluster
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $TrustedInfrastructureTrustedClustersKmsServicesFilterSpec -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$TrustedInfrastructureTrustedClustersKmsServicesFilterSpec)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureTrustedClustersKmsServicesFilterSpec -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureTrustedClustersKmsServicesFilterSpec -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $TrustedInfrastructureTrustedClustersKmsServicesFilterSpec = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $TrustedInfrastructureTrustedClustersKmsServicesFilterSpec) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $TrustedInfrastructureTrustedClustersKmsServicesFilterSpec | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $TrustedInfrastructureTrustedClustersKmsServicesFilterSpec = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $TrustedInfrastructureTrustedClustersKmsServicesFilterSpec) {
                    $LocalVarBodyParameter = $TrustedInfrastructureTrustedClustersKmsServicesFilterSpec | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "TrustedInfrastructureTrustedClustersKmsServicesSummary[]"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        foreach ($element in $SingleServerResult["Response"]) {
                            $element.PSObject.TypeNames.Insert(0, "TrustedInfrastructureTrustedClustersKmsServicesSummary")
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Returns basic information about all registered Key Provider Service instances in this vCenter. if you do not have all of the privileges described as follows:     -  Operation execution requires TrustedAdmin.ReadTrustedHosts.  

.DESCRIPTION

No description available.

.PARAMETER TrustedInfrastructureKmsServicesFilterSpec
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

TrustedInfrastructureKmsServicesSummary[]

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/kms/servicesactionquery/post/
#>
function Invoke-QueryKmsServices {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/vcenter/api/vcenter/trusted-infrastructure/kms/servicesactionquery/post/"
    )]
    Param (
        [Parameter(Mandatory = $false, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [PSTypeName("TrustedInfrastructureKmsServicesFilterSpec")]
        [PSCustomObject]
        ${TrustedInfrastructureKmsServicesFilterSpec},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-QueryKmsServices' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'QueryKmsServices' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/vcenter/trusted-infrastructure/kms/services__action=query'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $TrustedInfrastructureKmsServicesFilterSpec -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$TrustedInfrastructureKmsServicesFilterSpec)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureKmsServicesFilterSpec -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $TrustedInfrastructureKmsServicesFilterSpec -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $TrustedInfrastructureKmsServicesFilterSpec = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $TrustedInfrastructureKmsServicesFilterSpec) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $TrustedInfrastructureKmsServicesFilterSpec | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $TrustedInfrastructureKmsServicesFilterSpec = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $TrustedInfrastructureKmsServicesFilterSpec) {
                    $LocalVarBodyParameter = $TrustedInfrastructureKmsServicesFilterSpec | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "TrustedInfrastructureKmsServicesSummary[]"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        foreach ($element in $SingleServerResult["Response"]) {
                            $element.PSObject.TypeNames.Insert(0, "TrustedInfrastructureKmsServicesSummary")
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}


# SIG # Begin signature block
# MIIexgYJKoZIhvcNAQcCoIIetzCCHrMCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCCuiIcTimSA60SF
# VUrnZjY6JNhNqy62IgOz5xj/MXa626CCDdowggawMIIEmKADAgECAhAIrUCyYNKc
# TJ9ezam9k67ZMA0GCSqGSIb3DQEBDAUAMGIxCzAJBgNVBAYTAlVTMRUwEwYDVQQK
# EwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xITAfBgNV
# BAMTGERpZ2lDZXJ0IFRydXN0ZWQgUm9vdCBHNDAeFw0yMTA0MjkwMDAwMDBaFw0z
# NjA0MjgyMzU5NTlaMGkxCzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5EaWdpQ2VydCwg
# SW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1c3RlZCBHNCBDb2RlIFNpZ25pbmcg
# UlNBNDA5NiBTSEEzODQgMjAyMSBDQTEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAw
# ggIKAoICAQDVtC9C0CiteLdd1TlZG7GIQvUzjOs9gZdwxbvEhSYwn6SOaNhc9es0
# JAfhS0/TeEP0F9ce2vnS1WcaUk8OoVf8iJnBkcyBAz5NcCRks43iCH00fUyAVxJr
# Q5qZ8sU7H/Lvy0daE6ZMswEgJfMQ04uy+wjwiuCdCcBlp/qYgEk1hz1RGeiQIXhF
# LqGfLOEYwhrMxe6TSXBCMo/7xuoc82VokaJNTIIRSFJo3hC9FFdd6BgTZcV/sk+F
# LEikVoQ11vkunKoAFdE3/hoGlMJ8yOobMubKwvSnowMOdKWvObarYBLj6Na59zHh
# 3K3kGKDYwSNHR7OhD26jq22YBoMbt2pnLdK9RBqSEIGPsDsJ18ebMlrC/2pgVItJ
# wZPt4bRc4G/rJvmM1bL5OBDm6s6R9b7T+2+TYTRcvJNFKIM2KmYoX7BzzosmJQay
# g9Rc9hUZTO1i4F4z8ujo7AqnsAMrkbI2eb73rQgedaZlzLvjSFDzd5Ea/ttQokbI
# YViY9XwCFjyDKK05huzUtw1T0PhH5nUwjewwk3YUpltLXXRhTT8SkXbev1jLchAp
# QfDVxW0mdmgRQRNYmtwmKwH0iU1Z23jPgUo+QEdfyYFQc4UQIyFZYIpkVMHMIRro
# OBl8ZhzNeDhFMJlP/2NPTLuqDQhTQXxYPUez+rbsjDIJAsxsPAxWEQIDAQABo4IB
# WTCCAVUwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUaDfg67Y7+F8Rhvv+
# YXsIiGX0TkIwHwYDVR0jBBgwFoAU7NfjgtJxXWRM3y5nP+e6mK4cD08wDgYDVR0P
# AQH/BAQDAgGGMBMGA1UdJQQMMAoGCCsGAQUFBwMDMHcGCCsGAQUFBwEBBGswaTAk
# BggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNlcnQuY29tMEEGCCsGAQUFBzAC
# hjVodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20vRGlnaUNlcnRUcnVzdGVkUm9v
# dEc0LmNydDBDBgNVHR8EPDA6MDigNqA0hjJodHRwOi8vY3JsMy5kaWdpY2VydC5j
# b20vRGlnaUNlcnRUcnVzdGVkUm9vdEc0LmNybDAcBgNVHSAEFTATMAcGBWeBDAED
# MAgGBmeBDAEEATANBgkqhkiG9w0BAQwFAAOCAgEAOiNEPY0Idu6PvDqZ01bgAhql
# +Eg08yy25nRm95RysQDKr2wwJxMSnpBEn0v9nqN8JtU3vDpdSG2V1T9J9Ce7FoFF
# UP2cvbaF4HZ+N3HLIvdaqpDP9ZNq4+sg0dVQeYiaiorBtr2hSBh+3NiAGhEZGM1h
# mYFW9snjdufE5BtfQ/g+lP92OT2e1JnPSt0o618moZVYSNUa/tcnP/2Q0XaG3Ryw
# YFzzDaju4ImhvTnhOE7abrs2nfvlIVNaw8rpavGiPttDuDPITzgUkpn13c5Ubdld
# AhQfQDN8A+KVssIhdXNSy0bYxDQcoqVLjc1vdjcshT8azibpGL6QB7BDf5WIIIJw
# 8MzK7/0pNVwfiThV9zeKiwmhywvpMRr/LhlcOXHhvpynCgbWJme3kuZOX956rEnP
# LqR0kq3bPKSchh/jwVYbKyP/j7XqiHtwa+aguv06P0WmxOgWkVKLQcBIhEuWTatE
# QOON8BUozu3xGFYHKi8QxAwIZDwzj64ojDzLj4gLDb879M4ee47vtevLt/B3E+bn
# KD+sEq6lLyJsQfmCXBVmzGwOysWGw/YmMwwHS6DTBwJqakAwSEs0qFEgu60bhQji
# WQ1tygVQK+pKHJ6l/aCnHwZ05/LWUpD9r4VIIflXO7ScA+2GRfS0YW6/aOImYIbq
# yK+p/pQd52MbOoZWeE4wggciMIIFCqADAgECAhAOxvKydqFGoH0ObZNXteEIMA0G
# CSqGSIb3DQEBCwUAMGkxCzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5EaWdpQ2VydCwg
# SW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1c3RlZCBHNCBDb2RlIFNpZ25pbmcg
# UlNBNDA5NiBTSEEzODQgMjAyMSBDQTEwHhcNMjEwODEwMDAwMDAwWhcNMjMwODEw
# MjM1OTU5WjCBhzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExEjAQ
# BgNVBAcTCVBhbG8gQWx0bzEVMBMGA1UEChMMVk13YXJlLCBJbmMuMRUwEwYDVQQD
# EwxWTXdhcmUsIEluYy4xITAfBgkqhkiG9w0BCQEWEm5vcmVwbHlAdm13YXJlLmNv
# bTCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCCAYoCggGBAMD6lJG8OWkM12huIQpO
# /q9JnhhhW5UyW9if3/UnoFY3oqmp0JYX/ZrXogUHYXmbt2gk01zz2P5Z89mM4gqR
# bGYC2tx+Lez4GxVkyslVPI3PXYcYSaRp39JsF3yYifnp9R+ON8O3Gf5/4EaFmbeT
# ElDCFBfExPMqtSvPZDqekodzX+4SK1PIZxCyR3gml8R3/wzhb6Li0mG7l0evQUD0
# FQAbKJMlBk863apeX4ALFZtrnCpnMlOjRb85LsjV5Ku4OhxQi1jlf8wR+za9C3DU
# ki60/yiWPu+XXwEUqGInIihECBbp7hfFWrnCCaOgahsVpgz8kKg/XN4OFq7rbh4q
# 5IkTauqFhHaE7HKM5bbIBkZ+YJs2SYvu7aHjw4Z8aRjaIbXhI1G+NtaNY7kSRrE4
# fAyC2X2zV5i4a0AuAMM40C1Wm3gTaNtRTHnka/pbynUlFjP+KqAZhOniJg4AUfjX
# sG+PG1LH2+w/sfDl1A8liXSZU1qJtUs3wBQFoSGEaGBeDQIDAQABo4ICJTCCAiEw
# HwYDVR0jBBgwFoAUaDfg67Y7+F8Rhvv+YXsIiGX0TkIwHQYDVR0OBBYEFIhC+HL9
# QlvsWsztP/I5wYwdfCFNMB0GA1UdEQQWMBSBEm5vcmVwbHlAdm13YXJlLmNvbTAO
# BgNVHQ8BAf8EBAMCB4AwEwYDVR0lBAwwCgYIKwYBBQUHAwMwgbUGA1UdHwSBrTCB
# qjBToFGgT4ZNaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0VHJ1c3Rl
# ZEc0Q29kZVNpZ25pbmdSU0E0MDk2U0hBMzg0MjAyMUNBMS5jcmwwU6BRoE+GTWh0
# dHA6Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydFRydXN0ZWRHNENvZGVTaWdu
# aW5nUlNBNDA5NlNIQTM4NDIwMjFDQTEuY3JsMD4GA1UdIAQ3MDUwMwYGZ4EMAQQB
# MCkwJwYIKwYBBQUHAgEWG2h0dHA6Ly93d3cuZGlnaWNlcnQuY29tL0NQUzCBlAYI
# KwYBBQUHAQEEgYcwgYQwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0
# LmNvbTBcBggrBgEFBQcwAoZQaHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0Rp
# Z2lDZXJ0VHJ1c3RlZEc0Q29kZVNpZ25pbmdSU0E0MDk2U0hBMzg0MjAyMUNBMS5j
# cnQwDAYDVR0TAQH/BAIwADANBgkqhkiG9w0BAQsFAAOCAgEACQAYaQI6Nt2KgxdN
# 6qqfcHB33EZRSXkvs8O9iPZkdDjEx+2fgbBPLUvk9A7T8mRw7brbcJv4PLTYJDFo
# c5mlcmG7/5zwTOuIs2nBGXc/uxCnyW8p7kD4Y0JxPKEVQoIQ8lJS9Uy/hBjyakeV
# ef982JyzvDbOlLBy6AS3ZpXVkRY5y3Va+3v0R/0xJ+JRxUicQhiZRidq2TCiWEas
# d+tLL6jrKaBO+rmP52IM4eS9d4Yids7ogKEBAlJi0NbvuKO0CkgOlFjp1tOvD4sQ
# taHIMmqi40p4Tjyf/sY6yGjROXbMeeF1vlwbBAASPWpQuEIxrNHoVN30YfJyuOWj
# zdiJUTpeLn9XdjM3UlhfaHP+oIAKcmkd33c40SFRlQG9+P9Wlm7TcPxGU4wzXI8n
# Cw/h235jFlAAiWq9L2r7Un7YduqsheJVpGoXmRXJH0T2G2eNFS5/+2sLn98kN2Cn
# J7j6C242onjkZuGL2/+gqx8m5Jbpu9P4IAeTC1He/mX9j6XpIu+7uBoRVwuWD1i0
# N5SiUz7Lfnbr6Q1tHMXKDLFdwVKZos2AKEZhv4SU0WvenMJKDgkkhVeHPHbTahQf
# P1MetR8tdRs7uyTWAjPK5xf5DLEkXbMrUkpJ089fPvAGVHBcHRMqFA5egexOb6sj
# tKncUjJ1xAAtAExGdCh6VD2U5iYxghBCMIIQPgIBATB9MGkxCzAJBgNVBAYTAlVT
# MRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1
# c3RlZCBHNCBDb2RlIFNpZ25pbmcgUlNBNDA5NiBTSEEzODQgMjAyMSBDQTECEA7G
# 8rJ2oUagfQ5tk1e14QgwDQYJYIZIAWUDBAIBBQCggZYwGQYJKoZIhvcNAQkDMQwG
# CisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEOMAwGCisGAQQBgjcCARUwKgYKKwYB
# BAGCNwIBDDEcMBqhGIAWaHR0cDovL3d3dy52bXdhcmUuY29tLzAvBgkqhkiG9w0B
# CQQxIgQgy/LQ7UUYc0x8lezY4/aok+Q+1VVIlqtZDu8CX7lAcKswDQYJKoZIhvcN
# AQEBBQAEggGACHNVcYGmF3g+Q2cFu+ZunHgAM1BJvzkDFSDkKXPyIvc7KLQZGH4x
# V4Cmtni+9z5IlAWubzHqpAiV7N2Mq1rjEz/riLDdx6yaod7PziNhp5BoaNz4L6es
# 7VUa0qVo/Mvkv9007ka3ZGteqfTawqe53MFchajTyWoWYqmCYPHNf9PJmFZq7n5f
# kNDDw4AgJ0ZRCeC2wAs6jG8VPPb6o9a7VskyN4UQKaeTYvnm+B9Zm0NvfUqL7C9J
# cuhdd/Getc0mTV/D3oMCpZDj0lyuJqBnbG4haPJoalhyD+X8SBCBeFU1JD+oyAkp
# dxbcvaNVhtcSDVVvWd1yttwRQGiSQlpXAbUmA7u8EYhuyQGFBGSEKs0d0ccSxa2W
# hYd9hFkNtNo8zwQXMJtNbs8bkLfiadgqtf5SkComSHszBoqrR+2J6xzPHzF0Z/FS
# DR4AlPgJZMDRMTd5bacngtx8Ok4SQ7wR6bensY1Sy0TyXtgha4T4plj6a2VPBzea
# TxoqPl2zE8dboYINfTCCDXkGCisGAQQBgjcDAwExgg1pMIINZQYJKoZIhvcNAQcC
# oIINVjCCDVICAQMxDzANBglghkgBZQMEAgEFADB3BgsqhkiG9w0BCRABBKBoBGYw
# ZAIBAQYJYIZIAYb9bAcBMDEwDQYJYIZIAWUDBAIBBQAEIFyyQi0UCeJ1xNsQYcHE
# XYbkCi7v8DvmZkzmRLMhd3JBAhAhAseZpzhiQ1CLbKaw6z7SGA8yMDIxMDkyNDE2
# MDg1MVqgggo3MIIE/jCCA+agAwIBAgIQDUJK4L46iP9gQCHOFADw3TANBgkqhkiG
# 9w0BAQsFADByMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkw
# FwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMTEwLwYDVQQDEyhEaWdpQ2VydCBTSEEy
# IEFzc3VyZWQgSUQgVGltZXN0YW1waW5nIENBMB4XDTIxMDEwMTAwMDAwMFoXDTMx
# MDEwNjAwMDAwMFowSDELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDkRpZ2lDZXJ0LCBJ
# bmMuMSAwHgYDVQQDExdEaWdpQ2VydCBUaW1lc3RhbXAgMjAyMTCCASIwDQYJKoZI
# hvcNAQEBBQADggEPADCCAQoCggEBAMLmYYRnxYr1DQikRcpja1HXOhFCvQp1dU2U
# tAxQtSYQ/h3Ib5FrDJbnGlxI70Tlv5thzRWRYlq4/2cLnGP9NmqB+in43Stwhd4C
# GPN4bbx9+cdtCT2+anaH6Yq9+IRdHnbJ5MZ2djpT0dHTWjaPxqPhLxs6t2HWc+xO
# bTOKfF1FLUuxUOZBOjdWhtyTI433UCXoZObd048vV7WHIOsOjizVI9r0TXhG4wOD
# MSlKXAwxikqMiMX3MFr5FK8VX2xDSQn9JiNT9o1j6BqrW7EdMMKbaYK02/xWVLwf
# oYervnpbCiAvSwnJlaeNsvrWY4tOpXIc7p96AXP4Gdb+DUmEvQECAwEAAaOCAbgw
# ggG0MA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMBYGA1UdJQEB/wQMMAoG
# CCsGAQUFBwMIMEEGA1UdIAQ6MDgwNgYJYIZIAYb9bAcBMCkwJwYIKwYBBQUHAgEW
# G2h0dHA6Ly93d3cuZGlnaWNlcnQuY29tL0NQUzAfBgNVHSMEGDAWgBT0tuEgHf4p
# rtLkYaWyoiWyyBc1bjAdBgNVHQ4EFgQUNkSGjqS6sGa+vCgtHUQ23eNqerwwcQYD
# VR0fBGowaDAyoDCgLoYsaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL3NoYTItYXNz
# dXJlZC10cy5jcmwwMqAwoC6GLGh0dHA6Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9zaGEy
# LWFzc3VyZWQtdHMuY3JsMIGFBggrBgEFBQcBAQR5MHcwJAYIKwYBBQUHMAGGGGh0
# dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBPBggrBgEFBQcwAoZDaHR0cDovL2NhY2Vy
# dHMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0U0hBMkFzc3VyZWRJRFRpbWVzdGFtcGlu
# Z0NBLmNydDANBgkqhkiG9w0BAQsFAAOCAQEASBzctemaI7znGucgDo5nRv1CclF0
# CiNHo6uS0iXEcFm+FKDlJ4GlTRQVGQd58NEEw4bZO73+RAJmTe1ppA/2uHDPYuj1
# UUp4eTZ6J7fz51Kfk6ftQ55757TdQSKJ+4eiRgNO/PT+t2R3Y18jUmmDgvoaU+2Q
# zI2hF3MN9PNlOXBL85zWenvaDLw9MtAby/Vh/HUIAHa8gQ74wOFcz8QRcucbZEnY
# Ipp1FUL1LTI4gdr0YKK6tFL7XOBhJCVPst/JKahzQ1HavWPWH1ub9y4bTxMd90oN
# cX6Xt/Q/hOvB46NJofrOp79Wz7pZdmGJX36ntI5nePk2mOHLKNpbh6aKLzCCBTEw
# ggQZoAMCAQICEAqhJdbWMht+QeQF2jaXwhUwDQYJKoZIhvcNAQELBQAwZTELMAkG
# A1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRp
# Z2ljZXJ0LmNvbTEkMCIGA1UEAxMbRGlnaUNlcnQgQXNzdXJlZCBJRCBSb290IENB
# MB4XDTE2MDEwNzEyMDAwMFoXDTMxMDEwNzEyMDAwMFowcjELMAkGA1UEBhMCVVMx
# FTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNv
# bTExMC8GA1UEAxMoRGlnaUNlcnQgU0hBMiBBc3N1cmVkIElEIFRpbWVzdGFtcGlu
# ZyBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL3QMu5LzY9/3am6
# gpnFOVQoV7YjSsQOB0UzURB90Pl9TWh+57ag9I2ziOSXv2MhkJi/E7xX08PhfgjW
# ahQAOPcuHjvuzKb2Mln+X2U/4Jvr40ZHBhpVfgsnfsCi9aDg3iI/Dv9+lfvzo7oi
# PhisEeTwmQNtO4V8CdPuXciaC1TjqAlxa+DPIhAPdc9xck4Krd9AOly3UeGheRTG
# TSQjMF287DxgaqwvB8z98OpH2YhQXv1mblZhJymJhFHmgudGUP2UKiyn5HU+upgP
# hH+fMRTWrdXyZMt7HgXQhBlyF/EXBu89zdZN7wZC/aJTKk+FHcQdPK/P2qwQ9d2s
# rOlW/5MCAwEAAaOCAc4wggHKMB0GA1UdDgQWBBT0tuEgHf4prtLkYaWyoiWyyBc1
# bjAfBgNVHSMEGDAWgBRF66Kv9JLLgjEtUYunpyGd823IDzASBgNVHRMBAf8ECDAG
# AQH/AgEAMA4GA1UdDwEB/wQEAwIBhjATBgNVHSUEDDAKBggrBgEFBQcDCDB5Bggr
# BgEFBQcBAQRtMGswJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNv
# bTBDBggrBgEFBQcwAoY3aHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0RpZ2lD
# ZXJ0QXNzdXJlZElEUm9vdENBLmNydDCBgQYDVR0fBHoweDA6oDigNoY0aHR0cDov
# L2NybDQuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElEUm9vdENBLmNybDA6
# oDigNoY0aHR0cDovL2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElE
# Um9vdENBLmNybDBQBgNVHSAESTBHMDgGCmCGSAGG/WwAAgQwKjAoBggrBgEFBQcC
# ARYcaHR0cHM6Ly93d3cuZGlnaWNlcnQuY29tL0NQUzALBglghkgBhv1sBwEwDQYJ
# KoZIhvcNAQELBQADggEBAHGVEulRh1Zpze/d2nyqY3qzeM8GN0CE70uEv8rPAwL9
# xafDDiBCLK938ysfDCFaKrcFNB1qrpn4J6JmvwmqYN92pDqTD/iy0dh8GWLoXoIl
# HsS6HHssIeLWWywUNUMEaLLbdQLgcseY1jxk5R9IEBhfiThhTWJGJIdjjJFSLK8p
# ieV4H9YLFKWA1xJHcLN11ZOFk362kmf7U2GJqPVrlsD0WGkNfMgBsbkodbeZY4Ui
# jGHKeZR+WfyMD+NvtQEmtmyl7odRIeRYYJu6DC0rbaLEfrvEJStHAgh8Sa4TtuF8
# QkIoxhhWz0E0tmZdtnR79VYzIi8iNrJLokqV2PWmjlIxggKGMIICggIBATCBhjBy
# MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
# d3cuZGlnaWNlcnQuY29tMTEwLwYDVQQDEyhEaWdpQ2VydCBTSEEyIEFzc3VyZWQg
# SUQgVGltZXN0YW1waW5nIENBAhANQkrgvjqI/2BAIc4UAPDdMA0GCWCGSAFlAwQC
# AQUAoIHRMBoGCSqGSIb3DQEJAzENBgsqhkiG9w0BCRABBDAcBgkqhkiG9w0BCQUx
# DxcNMjEwOTI0MTYwODUxWjArBgsqhkiG9w0BCRACDDEcMBowGDAWBBTh14Ko4ZG+
# 72vKFpG1qrSUpiSb8zAvBgkqhkiG9w0BCQQxIgQgqQhsFNlvaZ5qxGMwb3jXygv7
# wuSe5+EHxv5KXi0NHaQwNwYLKoZIhvcNAQkQAi8xKDAmMCQwIgQgsxCQBrwK2YMH
# kVcp4EQDQVyD4ykrYU8mlkyNNXHs9akwDQYJKoZIhvcNAQEBBQAEggEACj5VXEf4
# hFp+l92yx2DtBxVElTU5igtoprI3CooM9/pu+CBKoCAmrQKft8nYRuNN1ShPo+g4
# /L6p6R1WQl6Vxrp88xmvfGhre38HSEK29POU/XXMN9v3yPx3CuE6zm+pcWjtlem4
# 1ijT+LD7PipzMyZvRLD80k01YIzFxWV1Xrovjtd1w+YJkoMqFILriojMZ21PyZpC
# jQ8EJWbJuNwIY3OqOJR951wvfhibpGtnBo8+eJK4MKGquoGcI0huxWOxzDs5KBEy
# kIVXTgZFNjzf7YTH8D5BEW9qqh8siUERPCOm1KGB/sDGsr3KdF1ClkQ0HFLBeBoQ
# IUiGcJgVv1d34A==
# SIG # End signature block
